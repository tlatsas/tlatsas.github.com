<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rebase | > kodama.gr_]]></title>
  <link href="http://www.kodama.gr/categories/rebase/atom.xml" rel="self"/>
  <link href="http://www.kodama.gr/"/>
  <updated>2013-11-04T21:06:03+02:00</updated>
  <id>http://www.kodama.gr/</id>
  <author>
    <name><![CDATA[Tasos Latsas]]></name>
    <email><![CDATA[tlatsas@gmx.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[using git rebase to remove duplicate cherry-picked commits]]></title>
    <link href="http://www.kodama.gr/2013/07/28/using-git-rebase-to-remove-duplicate-cherry-picked-commits/"/>
    <updated>2013-07-28T04:06:37+03:00</updated>
    <id>http://www.kodama.gr/2013/07/28/using-git-rebase-to-remove-duplicate-cherry-picked-commits</id>
    <content type="html"><![CDATA[<p>Git cherry-pick is a great tool, it allows you to select individual commits
from a branch and merge them into another. However, if the branch that you
cherry-picked from is eventually merged to the same branch that the individual
commits landed, you end up with duplicate commits.</p>

<p>To demonstrate this behaviour, we assume that we are working on a project
and at some point, we branched off to a <strong>dev</strong> branch to work on some exciting
new feature. As we are working we find some other important issues, or maybe
some minor issues that are not relevant to the new feature and decide to fix
them too. Now, there are two approaches we can take in such situation. The
first is to commit in our current branch and then use <code>git cherry-pick</code> to
introduce these changes to the <strong>master</strong> (or some other) branch. The second
approach is to <strong>stash</strong> any unsaved changes, create another branch
and commit these changes there. I personally prefer the second approach
as it makes your life way easier if your are contributing on a
project and need to make a pull request on Github or create a patch.
For our example, we will take the first approach and commit anyway.</p>

<p>So, after some work on the <strong>dev</strong> branch, the tree will look like this:</p>

<p><img src="/images/dev-branch.png" alt="dev branch" /></p>

<p>I have used silly commit messages like “cherry-pick this commit” to
indicate which commits we will cherry-pick into the <strong>master</strong>
branch. Let’s do that now:</p>

<pre><code>$ git checkout master
$ git cherry-pick e22c44f
$ git cherry-pick 1a2929a
</code></pre>

<p>If we use <code>git log</code> on master, we will notice that we have our new
commits, but with different SHA-1 hashes. This is happening because when
we cherry-pick commits, git creates <strong>new</strong>
commits on the <strong>master</strong> branch which introduce
the changes of these commits. At this point, the state of
the repo is the following:</p>

<p><img src="/images/after-cp.png" alt="repot state after cherry-pick" /></p>

<p>At some point, we are happy with the work on the <strong>dev</strong> branch, and
decide to merge the <strong>dev</strong> into <strong>master</strong>. However the <strong>master</strong>
branch has changes since the time we initially branched to work on our
features. This means that we <strong>cannot</strong> use a <strong>fast-forward</strong> merge.
If we switch to <strong>master</strong> branch and run <code>git merge dev</code> then a new
commit will be introduced. This is the standard behaviour of git when
doing <strong>no-fast-forward</strong> merges. Sometimes this may be desirable, but
some other times we prefer a linear history. This will be the repository
state after a merge:</p>

<p><img src="/images/no-ff-merge.png" alt="repo state after merge" /></p>

<p>And a <code>git log --oneline</code> will look like this:</p>

<pre><code>b05bcc3 Merge branch 'dev'
b47ebea 2nd commit to cherry-pick
9d190e9 cherry pick this commit
8c0a87e some more work before merging
d1c9568 2nd commit to cherry-pick
9d4575e even more commits
790c30a some more commits!
ac60758 more commits on dev branch
03725e0 cherry pick this commit
2e106d4 1st commit at dev branch
ee38cc6 second commit at master
444357a initial commit
</code></pre>

<p>Notice that except from the (ugly) new commit on top, we also ended up
with duplicate commits for each cherry-picked commit. Also, if you care
enough to use the <code>git show</code> command you will notice
that these duplicate commits contain the same changes.</p>

<p>This is where the <code>rebase</code> command comes into play. Rebase can be used
to rewrite the git history. It allows us to extract the changes of a
commit(s) and re-apply it ontop of a branch.</p>

<p>We will use it to introduce the new commits of
the <strong>master</strong> branch to our <strong>dev</strong> branch and then replay all the
work of the <strong>dev</strong> branch on top of these commits. In our use case,
the “new” commits of the <strong>master</strong> branch are the cherry-picked
changes. When rebase will start to re-apply our work, it is smart
enough to not apply the same changes the second time, and thus removing
the duplicate commits. Running:</p>

<pre><code>git checkout dev
git rebase master
</code></pre>

<p>will bring our repository in the following state:</p>

<p><img src="/images/after-rebase.png" alt="repo state after rebase" /></p>

<p>As you can see, the cherry-picked commits look like they never
existed on the <strong>dev</strong> branch. Also, now we can use a <strong>fast-forward</strong>
merge:</p>

<pre><code>git checkout master
git merge --ff dev
</code></pre>

<p>You can find more information about rebasing and cherry-pick at the
<a href="http://git-scm.com/">git-book</a> and the relevant
<a href="https://www.kernel.org/pub/software/scm/git/docs/">man pages</a>.</p>
]]></content>
  </entry>
  
</feed>
